# reids分布式锁

## 分布式锁解决方案

||实现思路|优点|缺点|
|:---|:----|:---:|:---|
|利用mysql的实现方案|利用数据库自身提供的锁的机制实现，要求数据库支持行级锁|实现简单，稳定可靠|性能差，无法适应高并发场景；容易出现死锁的情况；无法优雅的实现阻塞式锁；不可重入|
|利用redis的实现方案|使用缓存的CAS机制实现，保证对缓存操作序列的原子性|性能好|实现相对比较复杂；又出现死锁的可能性；无法优雅的实现阻塞式锁；不可重入|
|利用zookeeper的实现方案|基于zk的节点特性以及watch机制实现|性能好，稳定可靠性能较好的实现阻塞式锁以及可重入锁|实现相对复杂|

## redis加锁的正确姿势,来自于redis作者antirez的总结

### 加锁

通过setnx向特定的key写入一个随机值,并同事设置失效时间,写值成功既加锁成功:

​	注意点: 

- ​				必须给锁设置一个失效时间													避免死锁
- ​				加锁时，每个节点产生一个随机字符串							避免误删
- ​				写入随机值与设置失效时间必须同事的							保证加锁是原子性的

### 解锁

匹配随机值，删除redis上的特点key数据，要保证获取数据,判断一致性以及删除数据三个操作的原子的

执行如下lua脚本：

```lua
if redis.call("get",KEYS[1]) == ARGV[1] then
    return redis.call("del",KEYS[1])
else
    return 0
end
```

